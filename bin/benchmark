#!/usr/bin/env bash
##########################################
## ES-Ubuntu                            ##
##                                      ##
## benchmark                            ##
##                                      ##
## A wrapper and runner for `sysbench`. ##
## You can design multiple test runs    ##
## with different test parameters,      ##
## so you can benchmark the system for: ##
##   - CPU                              ##
##   - Memory                           ##
##   - Disks                            ##
##   - Download speed                   ##
## in a single script.                  ##
##########################################

############
## CONFIG ##
############

# Individual benchmark time limit (seconds)
test_run_time=60

## CPU
######

# Run parameters in semicolon limited string
# Threads ; Max prime number
runs_cpu[0]="1;30000"
runs_cpu[1]="16;30000"

# CPU test file size in MB
cpu_test_file_size=50

## Memory
#########

# Run parameters in semicolon limited string
# Threads ; Memory block size ; Memory total size ; Memory access mode
runs_memory[0]="1;512;30G;rnd"
runs_memory[1]="16;4K;50G;rnd"
runs_memory[2]="1;1M;100G;rnd"
runs_memory[3]="1;1M;100G;seq"

## Disk
#######

# Run parameters in semicolon limited string
# Threads ; Number of files ; Block size ; Test mode ; fsync after every request ; Read/write ratio ; Total files size
runs_disk[0]="1;64;4K;rndrw;on;3;4G"
runs_disk[1]="16;64;64K;rndrw;off;3;4G"
runs_disk[2]="1;1;1M;seqrd;off;3;4G"
runs_disk[3]="1;1;1M;seqwr;off;3;4G"

## Download Bandwidth
#####################

# Run parameters in semicolon limited string
# Name ; Location ; URL
runs_download[0]="CacheFly;Cloud;http://cachefly.cachefly.net/100mb.test"
runs_download[1]="Fibernet;Hungary;http://fibernet-bwt.loom.hu/downfile/mega.down"
runs_download[2]="Vultr;London;https://lon-gb-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[3]="Vultr;Frankfurt;https://fra-de-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[4]="Vultr;Paris;https://par-fr-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[5]="Vultr;Amsterdam;https://ams-nl-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[6]="Otenet;Athens;http://speedtest.ftp.otenet.gr/files/test1Gb.db"
runs_download[7]="Vultr;New York;https://nj-us-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[8]="Vultr;Dallas;https://tx-us-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[9]="Vultr;Los Angeles;https://lax-ca-us-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[10]="Vultr;Tokyo;https://hnd-jp-ping.vultr.com/vultr.com.1000MB.bin"
runs_download[11]="Vultr;Sydney;https://syd-au-ping.vultr.com/vultr.com.1000MB.bin"

###############
## FUNCTIONS ##
###############

## Version
##########
version(){
    cat <<EOF
Benchmark v1.0.2
Written by Sandor Semsey, Copyright(C) 2020, License MIT
EOF
}

## Usage
########
usage(){
    cat <<EOF

Usage: benchmark [OPTIONS]...

OPTIONS:

-c, --cpu
-m, --memory
-d, --disk
    --download
                       Run appropriate test. If no test specified, all will run.
-s, --system           Run only a system check
-r, --report           Save test report to file
    --report-prefix    Report file prefix, implies '-r'

-h, --help             Display this help
-v, --version          Print version
EOF
    exit 0
}

## Check if command exists
##
## @param    $1  Command
##########################
command_exists(){
    command -v "${@}" >/dev/null 2>&1
}

## Clean up after tests
#######################
clean_up(){
    rm -f test_file.*
    exit
}

## Test CPU with real use cases
###############################
cpu_app_test(){
    local time_sha time_bzip time_aes

    dd if=/dev/urandom of="test_file.cpu" bs=1M count="${cpu_test_file_size}" >/dev/null 2>&1

    time_sha=$({ TIME='%e seconds' time sha256sum >/dev/null <"test_file.cpu"; } 2>&1)
    time_bzip=$({ TIME='%e seconds' time bzip2 >/dev/null <"test_file.cpu"; } 2>&1)
    time_aes=$({ TIME='%e seconds' time openssl enc -e -aes-256-cbc -pass pass:12345678 -pbkdf2 >/dev/null <"test_file.cpu"; } 2>&1)

    printf "%-20s %s\n" "SHA256-hashing:" "${time_sha}"
    printf "%-20s %s\n" "bzip2-compressing:" "${time_bzip}"
    printf "%-20s %s\n" "AES-encrypting:" "${time_aes}"

    rm -f "test_file.cpu"
}

## Benchmark
##
## @param    $1  Type of benchmark
## @param    $@  Params for benchmark
#####################################
run_benchmark(){
    local type="${1?:"Benchmark type missing"}"
    local params=("--time=${test_run_time}")

    # Compile params
    case "${type}" in
        cpu) params=("${params[@]}" "--threads=${2}" "--cpu-max-prime=${3}" cpu) ;;
        memory) params=("${params[@]}" "--threads=${2}" "--memory-block-size=${3}" "--memory-total-size=${4}" "--memory-access-mode=${5}" memory) ;;
        disk) params=("${params[@]}" "--threads=${2}" "--file-num=${3}" "--file-block-size=${4}" "--file-test-mode=${5}" "--file-fsync-all=${6}" "--file-rw-ratio=${7}" "--file-total-size=${8}" fileio) ;;
        download)
            curl -4 --max-time 10 -so /dev/null -w '%{speed_download}\n' --url "${4}"
            return 0
            ;;
        *)
            echo "Not supported type" >&2
            return 1
            ;;
    esac

    # Run benchmark
    [[ "${type}" == "disk" ]] && sysbench "${params[@]}" prepare
    sysbench "${params[@]}" run
    [[ "${type}" == "disk" ]] && sysbench "${params[@]}" cleanup

    return 0
}

## Filter benchmark results for summary
##
## @param    $1  Name of benchmark
## @param    $2  Raw results
#######################################
filter_results(){
    local type="${1?:"Benchmark type missing"}"
    local raw="${2?:"Raw results missing"}"
    local filter

    case "${type}" in
        cpu_app) filter='/^SHA256-hashing/ p; /^bzip2-compressing/ p; /^AES-encrypting/ p;' ;;
        cpu) filter=' /^CPU speed:/,+1 p; /^Latency/,+3 p' ;;
        memory) filter='/transferred/ p; /^Latency/,+3 p' ;;
        disk) filter='/^Throughput/,+2 p; /^Latency/,+3 p' ;;
        download)
            awk '{ printf "%d MBit/s\n", $0 * 8 / 1000 / 1000 } END { if (NR == 0) { print "error" } }' <<<"${raw}"
            return 0
            ;;
        *)
            echo "Not supported type" >&2
            return 1
            ;;
    esac

    sed -n "${filter}" <<<"${raw}"
}

## Print test header with system info
#####################################
print_sysinfo(){
    cat <<EOF
--------------------------------------------------------
 Benchmark v1.0.2

 ${hostname}
--------------------------------------------------------

========================================================
                      SYSTEM INFO
========================================================

                          CPU
********************************************************
Vendor: ${cpu_vendor}
Model : ${cpu_model}
Cores :  ${cpu_cores}
MHz   : ${cpu_freq}
Cache : ${cpu_cache}

                        Memory
********************************************************
Total : ${ram_total}
Free  : ${ram_free}
Swap  : ${ram_swap}

                    Operating System
********************************************************
OS     : ${os}
Kernel : ${kernel}
Arch   : ${arch}

                         Disks
********************************************************
Device    Capacity    Type
--------------------------
${disks}

EOF
}

## Print summary header
#######################
print_summary_header(){
    cat <<EOF
========================================================
                      TEST RESULTS

 ${hostname}
 $(date +"%F %R")

 Total run time: $((SECONDS / 60)) min $((SECONDS % 60)) sec
========================================================
EOF
}

## Print summary
##
## @param    $1  Name of benchmark
##################################
print_summary(){
    local testname="${1}"
    run_data="runs_${testname}[@]"

    # Header
    printf "\n%30s\n********************************************************\n" "${testname^^}"

    # Parallel runs
    i=0
    for run_param in "${!run_data}"; do
        selector="${type}_${i}"
        IFS=";" read -r -a params <<<"${run_param}"

        # Run header
        printf "\nRun #%d\n------\n\n" $((i + 1))

        # Print run parameters
        case "${testname}" in
            cpu)
                printf "%-17s : %32d\n" "Number of threads" "${params[0]}"
                printf "%-17s : %32d\n\n" "Max prime number" "${params[1]}"
                ;;
            memory)
                printf "%-17s : %8d\n" "Number of threads" "${params[0]}"
                printf "%-17s : %8s\n" "Memory block size" "${params[1]}"
                printf "%-17s : %8s\n" "Memory total size" "${params[2]}"
                printf "%-17s : %8s\n\n" "Memory access mode" "${params[3]}"
                ;;
            disk)
                printf "%-17s : %8s\n" "Number of threads" "${params[0]}"
                printf "%-17s : %8s\n" "Number of files" "${params[1]}"
                printf "%-17s : %8s\n" "File block size" "${params[2]}"
                printf "%-17s : %8s\n" "Test mode" "${params[3]}"
                printf "%-17s : %8s\n" "fsync on all" "${params[4]}"
                printf "%-17s : %8s\n" "Read/write ratio" "${params[5]}"
                printf "%-17s : %8s\n\n" "Total file size" "${params[6]}"
                ;;
            download)
                printf "%-15s [%-10s]  : " "${params[1]}" "${params[0]}"
                ;;
        esac

        # Run results
        echo "${summary[${selector}]}"
        i=$((i + 1))
    done

    # Print CPU application test results
    if [[ "${testname}" == "cpu" ]]; then
        printf "\nApplication test\n----------------\n\n%s\n" "${summary[cpu_app]}"
    fi
}

##################
## SCRIPT START ##
##################

# Strict mode
set -euo pipefail
IFS=$'\n\t'

# Make sure test files are always deleted, even when the script is interrupted
trap clean_up EXIT INT TERM

tests=()
declare -A summary

# Parse options
create_report=""
report_file_prefix=""
sys_check=""
while :; do
    case "${1:-}" in
        -r | --report) create_report=1 ;;
        --report-prefix)
            shift
            report_file_prefix="${1}"
            create_report=1
            ;;
        -c | --cpu) tests+=("cpu") ;;
        -m | --memory) tests+=("memory") ;;
        -d | --disk) tests+=("disk") ;;
        --download) tests+=("download") ;;
        -s | --system) sys_check=1 ;;
        -h | --help)
            version
            usage
            exit 0
            ;;
        -v | --version)
            version
            exit 0
            ;;
        "") break ;;
        *)
            echo "Not supported option: ${1}" >&2
            usage
            exit 1
            ;;
    esac
    shift
done

# If no test specified --> run all
[[ -z "${tests[*]}" ]] && tests=(cpu memory disk download)

# Check for required commands
if [[ -z "${sys_check}" ]]; then
    required_commands=(dd sha256sum bzip2 openssl lsblk sysbench curl)
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "${cmd}"; then
            echo "Missing dependency: ${cmd}" >&2
            exit 1
        fi
    done
fi

## Get System info
##################
# CPU info
cpu_info="$(cat /proc/cpuinfo)"
cpu_model=$(grep -m 1 "model name" <<<"${cpu_info}" | cut -d ":" -f 2)
cpu_vendor=$(grep -m 1 "vendor_id" <<<"${cpu_info}" | cut -d ":" -f 2)
cpu_freq=$(grep -m 1 "cpu MHz" <<<"${cpu_info}" | cut -d ":" -f 2)
cpu_cache=$(grep -m 1 "cache size" <<<"${cpu_info}" | cut -d ":" -f 2)
cpu_cores=$(awk -F: '/model name/ {core++} END {print core}' <<<"${cpu_info}")

# RAM info
ram_info="$(free -h)"
ram_total=$(grep "Mem:" <<<"${ram_info}" | awk '{print $2}')
ram_free=$(grep "Mem:" <<<"${ram_info}" | awk '{print $4}')
ram_swap=$(grep "Swap:" <<<"${ram_info}" | awk '{print $2}')

# OS info
host=$(hostnamectl)
hostname=$(hostname)
os=$(grep -m 1 "Operating" <<<"${host}" | cut -d ":" -f 2)
kernel=$(grep -m 1 "Kernel" <<<"${host}" | cut -d ":" -f 2)
arch=$(grep -m 1 "Architecture" <<<"${host}" | cut -d ":" -f 2)

# Disks
disks=$(lsblk --nodeps --noheadings --output NAME,SIZE,ROTA --exclude 1,2,7,11 | sort | awk '{if ($3 == 0) {$3="SSD"} else {$3="HDD"}; printf("%-10s%-12s%-3s\n", $1, $2, $3)}')

# If we need to save report to file --> set filename
# else: discard report (only output to terminal)
if [[ -n "${create_report}" ]]; then
    output_file="${report_file_prefix}${hostname}_$(date +"%F_%H_%M")"
else
    output_file=/dev/null
fi

# Sysinfo
print_sysinfo | tee "${output_file}"
[[ -n "${sys_check}" ]] && exit 0

# Run Benchmarks
echo "Start Benchmarking..."
for type in "${tests[@]}"; do
    run_data="runs_${type}[@]"

    if [[ "${type}" == "cpu" ]]; then
        echo "Running CPU application test..."
        results=$(cpu_app_test)
        summary[cpu_app]="$(filter_results cpu_app "${results}")"
    fi

    # Parallel runs
    i=0
    for run_param in "${!run_data}"; do
        selector="${type}_${i}"
        IFS=";" read -r -a params <<<"${run_param}"

        echo "Running ${type^^} benchmark #$((i + 1))..."
        results=$(run_benchmark "${type}" "${params[@]}")
        summary[${selector}]=$(filter_results "${type}" "${results}")

        i=$((i + 1))
    done
done

echo "Benchmarking finished."
echo

## Summary
##########
print_summary_header | tee -a "${output_file}"

for type in "${tests[@]}"; do
    print_summary "${type}" | tee -a "${output_file}"
done

exit 0
